# 代码规范 (Code Specifications)

本项目遵循以下代码规范和约定，请在协助开发时遵守：

## 1. 语言和工具 (Language and Tools)

-   **主要语言 (Primary Language):** Rust
-   **包管理器 (Package Manager):** Cargo
-   **格式化 (Formatting):** 使用 `rustfmt` 进行代码格式化。请确保所有提交的代码都已通过 `cargo fmt`。
-   **代码检查 (Linting):** 使用 `clippy` 进行代码质量检查。请尽量修复 `cargo clippy` 报告的所有警告。

## 2. 编码风格 (Coding Style)

-   **命名规范 (Naming Conventions):** 严格遵循 Rust 官方的 [API 设计规范](https://rust-lang.github.io/api-guidelines/naming.html) 中的命名约定：
    -   类型 (`struct`, `enum`, `trait`)：使用 `PascalCase` (例如 `PriceAnalyzer`, `ConnectionManager`)。
    -   变量、函数、方法：使用 `snake_case` (例如 `current_price`, `calculate_moving_average`)。
    -   模块：使用 `snake_case`。
    -   常量：使用 `SCREAMING_SNAKE_CASE` (例如 `MAX_CONNECTIONS`)。
-   **错误处理 (Error Handling):** 优先使用 `Result<T, E>` 处理可恢复错误。对于不可恢复错误，可以使用 `panic!`，但应尽量避免。推荐使用 `thiserror` 或 `anyhow` 等库来简化错误处理。
-   **文档注释 (Documentation Comments):** 为所有公共的 `struct`, `enum`, `function`, `method`, `module` 添加文档注释 (`///`)，解释其用途、参数、返回值和注意事项。
-   **代码结构 (Code Structure):** 保持代码简洁、清晰、高效。合理使用函数和模块分解复杂逻辑，提高代码的可读性和可维护性。

## 3. 结构与设计 (Structure and Design)

-   **模块化 (Modularity):** 合理组织代码结构，使用 `mod` 将代码划分为逻辑单元，明确模块职责，提高可读性和可维护性。
-   **类型设计 (Type Design):** 根据功能模块化设计 `struct` 和 `enum`，确保其职责单一，遵循良好的设计原则（如 SOLID 中的单一职责原则）。
-   **函数/方法设计 (Function/Method Design):** 将复杂逻辑拆分为更小的、单一职责的函数或方法。优先编写纯函数。充分利用 Rust 的类型系统和特性（如 Traits, Generics）来实现代码复用和抽象。
-   **接口设计 (Interface Design):** 设计清晰、稳定和易于使用的公共 API（函数、方法、类型）。

## 4. 依赖管理 (Dependency Management)

-   **添加依赖 (Adding Dependencies):** 通过 `Cargo.toml` 文件管理依赖。添加新依赖时，请选择稳定、维护良好且信誉可靠的库。考虑依赖项的大小和编译时间。
-   **更新依赖 (Updating Dependencies):** 定期使用 `cargo update` 更新依赖，并注意检查更新可能带来的兼容性问题或安全漏洞。

## 5. 测试 (Testing)

-   **单元测试 (Unit Tests):** 为核心功能和复杂逻辑编写单元测试，确保代码的正确性。测试代码应放在源文件内的 `#[cfg(test)]` 模块中。
-   **集成测试 (Integration Tests):** 在 `tests` 目录下编写集成测试，测试模块、库或程序作为一个整体的行为，以及它们之间的交互。
-   **测试覆盖率 (Test Coverage):** 鼓励提高测试覆盖率，以增强代码质量信心。

## 6. 性能与优化 (Performance and Optimization)

-   **性能意识 (Performance Awareness):** 关注关键路径的性能，但在优化前优先保证代码的正确性、可读性和简洁性。使用性能分析工具（如 `cargo flamegraph`）来识别瓶颈。
-   **内存效率 (Memory Efficiency):** 注意内存使用效率，合理选择数据结构（例如 `Vec` vs `slice`, `String` vs `&str`），避免不必要的内存分配、克隆和拷贝。深入理解并善用 Rust 的所有权和借用系统。
-   **算法选择 (Algorithm Choice):** 选择合适的数据结构和算法以满足性能要求。
-   **并发与并行 (Concurrency & Parallelism):** 在需要时，利用 Rust 的并发安全特性和库（如 `std::thread`, `rayon`, `tokio`）来提高性能，但需注意复杂性和潜在的并发问题。

## 7. 代码质量与维护 (Code Quality and Maintenance)

-   **代码简洁性 (Code Conciseness):** 努力消除冗余代码，利用 Rust 的特性（如模式匹配、迭代器）编写更简洁、表达力更强的代码。
-   **健壮性 (Robustness):** 编写健壮的代码，进行适当的输入验证和边界条件检查。通过全面的错误处理提高程序的容错能力（防御性编程）。
-   **可读性 (Readability):** 编写易于理解和维护的代码。使用有意义的变量名和函数名，添加必要的注释来解释复杂的逻辑或意图。
-   **重构 (Refactoring):** 定期回顾和重构代码，以改进设计、提高可读性、减少技术债务。

## 8. 安全 (Security)

-   **内存安全 (Memory Safety):** 尽可能避免使用 `unsafe` 代码。如果必须使用，必须有充分的理由，严格限定其范围，并添加详细注释解释其必要性和安全性保证。
-   **并发安全 (Concurrency Safety):** 利用 Rust 的类型系统保证线程安全，谨慎处理共享状态和锁。
-   **输入安全 (Input Safety):** 对所有外部输入（用户输入、网络数据、文件内容等）进行严格的验证和清理，防止注入攻击等安全漏洞。
-   **依赖安全 (Dependency Security):** 使用 `cargo audit` 或类似工具检查依赖项中的已知安全漏洞。

## 9. 沟通语言 (Communication Language)

-   请使用 **中文** 进行沟通和交流。
